# vim: ts=2 sts=2 sw=2 et
jenkins:
  # Don't run jobs on master. Move everything to agents.
  numExecutors: 0
  mode: EXCLUSIVE
  crumbIssuer:
    standard:
      excludeClientIPFromCrumb: false
  globalNodeProperties:
    - envVars:
        env:
          - key: PIP_DOWNLOAD_CACHE
            value: /var/cache/jenkins/pip

  authorizationStrategy:
    loggedInUsersCanDoAnything:
      allowAnonymousRead: false

  remotingSecurity:
    enabled: true

  clouds:
    - docker:
        name: "Host docker"
        containerCap: 10
        dockerApi:
          dockerHost:
            uri: "unix:///var/run/docker.sock"
        templates:
          - labelString: "jenkins-job"
            name: "jenkins-job"
            instanceCapStr: "0"
            dockerTemplateBase:
              image: "docker.sunet.se/sunet/jenkins-job"
              # This is the magic startup command who maps "localhost" to
              # the docker host machine to have docker run -p xx:yy work
              # from inside containers.
              dockerCommand: "/run.sh"
              # and that run.sh needs a tty to not exit.
              tty: true
              # Volumes to run docker-in-docker
              # and to cache pip downloads
              volumes:
                - "/usr/bin/docker:/usr/bin/docker:ro"
                - "/var/run/docker.sock:/var/run/docker.sock"
                - "pip_download_cache:/var/cache/jenkins/pip:rw"
            remoteFs: "/home/jenkins/"
            connector:
              attach:
                user: ""
            # pullStrategy variable in jcasc
            # Default to "PROD" value PULL_ALWAYS
            pullStrategy: "${pullStrategy:-PULL_ALWAYS}"


unclassified:
  location:
    url: https://jenkins.jenkins.docker/

  sshPublisher:
    commonConfig:
      disableAllExec: false
# Not supported yet.
# We're doing this in groovy instead.
#    hostConfigurations:
#      - BapSshHostConfiguration:
#          name: pypi.sunet.se
#          hostname: pypi.sunet.se
#          username: pypi
#          remoteRootDir: /home/pypi/packages/

tool:
  git:
    installations:
      - name: Default
        home: git


# Not supported.
# We're doing this in groovy instead.
#locale:
#  systemLocale: en_US
#  ignoreAcceptLanguage: true


# We need to disable jobdsl security due to our Yaml library used in jobdsl.
security:
  GlobalJobDslSecurityConfiguration:
    useScriptSecurity: false
# Not supported.
# We're doing this in groovy instead.
#  updateSiteWarningsConfiguration:
#    ignoredWarnings:
#      - 'SECURITY-248'


credentials:
  system:
    domainCredentials:
      - credentials:
        - string:
            description: "Token to send notifications to Sunet Slack"
            id: 'SLACK_TOKEN'
            scope: 'GLOBAL'
            secret: '${SLACK_TOKEN}'


jobs:
  - script: >
      job('bootstrap-docker-builds') {
          /* OK, use this when we're rid of the needed yaml library,
          and can start to run job-dsl in sandbox
          properties {
              authorizeProjectProperty {
                  strategy {
                      specificUsersAuthorizationStrategy {
                          userid('admin')
                          useApitoken(false)
                          apitoken('')
                          password('')
                      }
                  }
              }
          }
          */
          triggers {
              // put the job on a cron to run in 1 minute after the rest of the casc configuration finishes loading
              // This is to workaround the fact that queue() doesn't work here, because the queue haven't inited yet.
              def currentDate = new Date()
              currentDate.set(minute: currentDate.minutes + 1)
              def delay = currentDate
              def cron_1_minute = '' + delay.getMinutes() + ' ' + delay.getHours() + ' ' + delay[Calendar.DAY_OF_MONTH] + ' ' + (delay.getMonth()+1) + ' *'
              cron(cron_1_minute)
          }
          wrappers {
              // DEV_MODE is expanded by jcasc
              if (${DEV_MODE:-false}) {
                  environmentVariables {
                      env('DEV_MODE', '${DEV_MODE}')
                  }
              }
              credentialsBinding {
                  string {
                      variable('SLACK_TOKEN')
                      credentialsId('SLACK_TOKEN')
                  }
              }
          }
          scm {
              git {
                  remote {
                      // DEV_MODE is expanded by jcasc
                      if (${DEV_MODE:-false}) {
                          // Rely on run.sh localhost mapping, to exposed gitd
                          url('git://localhost/bootstrap-docker-builds')
                      } else {
                          // When we detect prod, use github directly
                          github('sunet/bootstrap-docker-builds')
                      }
                  }
                  branch("master")
              }
          }
          steps {
              jobDsl {
                  targets('github_docker_repos.groovy')
                  additionalClasspath('lib/*.jar')
                  sandbox(true)
                  ignoreExisting(false)
                  removedJobAction('DELETE')
                  removedViewAction('DELETE')
                  removedConfigFilesAction('DELETE')
                  lookupStrategy("SEED_JOB")
                  failOnMissingPlugin(true)
                  unstableOnDeprecation(true)
                  failOnSeedCollision(true)
              }
          }
      }
# Nope, worked around with cron() instead.
#  - script: queue('bootstrap-docker-builds')
